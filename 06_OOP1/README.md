# 面向对象编程（基础）

## 面向对象编程的基本概念

1. 面向对象内容的三条主线：

   - Java 类及类的成员：（重点）属性、方法、构造器；（熟悉）代码块、内部类
   - 面向对象的特征：封装、继承、多态、（抽象）
   - 其他关键字的使用：this、super、package、import、static、final、interface、abstract 等

2. 面向过程编程(POP) vs 面向对象编程(OOP)

   2.1 简单的语言描述二者的区别

   面向过程：

   - 以**函数**为组织单位。
   - 是一种“执行者思维”，适合解决简单问题。扩展能力差、后期维护难度较大。

   面向对象：

   - 以**类**为组织单位。每种事物都具备自己的**属性**和**行为/功能**。
   - 是一种“设计者思维”，适合解决复杂问题。代码扩展性强、可维护性高。

   两者各有优劣。在实际开发中，我们应该结合实际情况，灵活使用。

   2.2 二者关系

   我们千万不要把面向过程和面向对象对立起来。他们是相辅相成的。面向对象离不开面向过程！

3. 面向对象编程的两个核心概念

   即：类（Class）、对象（Object）

   > 谈谈对这两个概念的理解？
   >
   > - 类:具有相同特征的事物的抽象描述，是**抽象的**、概念上的定义。
   > - 对象：实际存在的该类事物的**每个个体**，是**具体的**，因而也称为**实例(instance)**。

4. 类的声明与使用

   4.1 体会：设计类，其实就是设计类的成员

   ```java
   class Person{

   }
   ```

   4.2 类的内部成员一、二：

   - 成员之一：属性、成员变量、field（字段、域）
   - 成员之二：（成员）方法、函数、method

     4.3 类的实例化

   等价描述：类的实例化 <=> 创建类的对象 <=> 创建类的实例

   格式：类类型 对象名 = 通过 new 创建的对象实体

   举例：

   ```java
   Phone p1 = new Phone();
   Scanner scan = new Scanner(System.in);
   String str = new String();
   ```

5. 面向对象完成具体功能的操作的三步流程（非常重要）

   - 步骤 1：创建类，并设计类的内部成员（属性、方法）
   - 步骤 2：创建类的对象。比如：Phone p1 = new Phone();
   - 步骤 3：通过对象，调用其内部声明的属性或方法，完成相关的功能

## 对象在内存中的结构

1. 对象在内存中的分配涉及到的内存结构（理论）

   - 栈(stack): 方法内定义的变量，存储在栈中。
   - 堆(heap) : new 出来的结构（比如：数组实体、对象的实体）。包括对象中的属性
   - 方法区(method area) : 存放类的模板。比如：Person 类的模板

2. 类中对象的内存解析

   2.1 创建类的一个对象

   见《01-创建类的一个对象.png》

   2.2 创建类的多个对象

   见《02-创建类的多个对象 1.png》、《02-创建类的多个对象 2.png》

3. 实例

   强调 1：创建了 Person 类的两个对象

   ```java
   Person p1 = new Person();
   Person p2 = new Person();
   ```

   说明：创建类的多个对象时，每个对象在堆空间中有一个对象实体。每个对象实体中保存着一份类的属性。

   如果修改某一个对象的某属性值时，不会影响其他对象此属性的值。

   ```java
   p1.age = 10;
   p2.age = 20;

   p1.age = 30;
   System.out.println(p2.age);//20
   ```

   强调 2：声明类的两个变量

   ```java
   Person p1 = new Person();
   Person p3 = p1;
   ```

   说明：此时的 p1，p3 两个变量指向了堆空间中的同一个对象实体。（或 p1,p3 保存的地址值相同）

   如果通过其中某一个对象变量修改对象的属性时，会影响另一个对象变量此属性的值。

   ```java
   p1.age = 10;
   p3.age = 20;
   System.out.println(p1.age);//20
   ```

   2.3 对象调用方法的过程（在"03-类的成员之二：方法"中讲解）

## 类的成员之一：属性

1. 变量的分类：

   - 角度一，按照数据类型来分：

     基本数据类型（8 种）、引用数据类型（数组、类、接口、枚举、注解、记录）

   - 角度二，按照变量在类中声明的位置的不同：

     成员变量（或属性）、局部变量（方法内、方法形参、构造器内、构造器形参、代码块内等）

2. 属性的几个称谓：成员变量、属性、field（字段、域）

3. 区分成员变量 vs 局部变量

   相同点：

   - 变量声明的格式相同：数据类型 变量名 = 变量值
   - 变量都有其有效的作用域。出了作用域，就失效了。
   - 变量必须先声明，后赋值，再使用。

   不同点：

   1. 类中声明的位置的不同：

      - 属性：声明在类内，方法外的变量
      - 局部变量：声明方法、构造器内部的变量

   2. 在内存中分配的位置不同（难）：

      - 属性：随着对象的创建，存储在堆空间中
      - 局部变量：存储在栈空间中

   3. 生命周期：

      - 属性：随着对象的创建而创建，随着对象的消亡而消亡。
      - 局部变量：随着方法对应的栈帧入栈，局部变量会在栈中分配；随着方法对应的栈帧出栈，局部变量消亡。

   4. 作用域：

      - 属性：在整个类的内部都是有效的
      - 局部变量：仅限于声明此局部变量所在的方法（或构造器、代码块）中

   5. 是否可以有权限修饰符进行修饰：(难)

      都有哪些权限修饰符：public、protected、缺省、private。（用于表明所修饰的结构可调用的范围的大小）

      - 属性：是可以使用权限修饰符进行修饰的。暂时还未讲封装性，所以大家先不用写任何权限符。
      - 局部变量：不能使用任何权限修饰符进行修饰的。

   6. 是否有默认值：(重点)

      - 属性：都有默认初始化值。意味着，如果没有给属性进行显式初始化赋值，则会有默认初始化值。
      - 局部变量：都没有默认初始化值。意味着，在使用局部变量之前，必须要显式的赋值，否则报错。

      注意：对于方法的形参而言，在调用方法时，给此形参赋值即可。

## 类的成员之二：方法(method)

1. 使用方法的好处

   方法的理解：**方法**是类或对象行为特征的抽象，用来完成某个功能操作。

   方法的好处：实现代码重用，减少冗余，简化代码

2. 使用举例

   - `Math.random()` 的 `random()` 方法
   - `Math.sqrt(x)` 的 `sqrt(x)` 方法
   - `System.out.println(x)` 的 `println(x)` 方法
   - `new Scanner(System.in).nextInt()` 的 `nextInt()` 方法
   - Arrays 类中的 `binarySearch()` 方法、`sort()` 方法、`equals()` 方法

3. 声明举例

   ```java
   public void eat()
   public void sleep(int hour)
   public String interests(String hobby)
   public int getAge()
   ```

4. 方法声明的格式 (重要)

   ```java
   权限修饰符 [其它修饰符] 返回值类型 方法名(形参列表) [throws 异常类型]{ //方法头
      //方法体
   }
   ```

   注：`[]` 中的内部不是必须的，以后再讲。

5. 具体的方法声明的细节

   5.1 权限修饰符

   Java 规定了哪些权限修饰符呢？有四种：private \ 缺省 \ protected \ public (放到封装性讲)

   暂时大家声明方法时，可以先都写成 public 的。

   5.2 返回值类型：描述当调用完此方法时，是否需要返回一个结果。

   分类：

   - 无返回值类型：使用 void 表示即可。比如：System.out.println(x)的 println(x)方法、Arrays 的 sort()
   - 有具体的返回值类型：需要指明返回的数据的类型。可以是基本数据类型，也可以引用数据类型
     > 需要在方法内部配合使用"return + 返回值类型的变量或常量"
     > 比如：`Math.random()`、`new Scanner(System.in).nextInt()` 等

   [经验] 我们在声明方法时，要不要提供返回值类型呢？

   - 根据方法具体实现的功能来决定。换句话说，具体问题具体分析
   - 根据题目要求

   根据以上的分析，我们可以得出结论：方法声明时，是可以没有返回值类型的。但是，如果方法内部有 return 语句，则必须要有返回值类型，同时，返回值类型要与 return 语句返回的值类型一致。

   5.3 方法名：属于标识符。需要满足标识符的规定和规范。“见名知意”

   5.4 形参列表：形参，属于局部变量，且可以声明多个。

   格式：(形参类型 1 形参 1,形参类型 2 形参 2,...)
   分类：无形参列表 、 有形参列表

   - 无形参列表：不能省略一对()。

     比如：`Math.random()`、`new Scanner(System.in).nextInt()`

   - 有形参列表：根据方法调用时，需要的不确定的变量的类型和个数，确定形参的类型和个数。

     比如：Arrays 类中的 `binarySearch()` 方法、`sort()` 方法、`equals()` 方法

   [经验] 我们在声明方法时，是否需要形参列表呢？

   - 根据方法具体实现的功能来决定。换句话说，具体问题具体分析
   - 根据题目要求

   总之，方法声明时，是可以没有形参列表的。但是，如果方法调用时，需要传入实参，则必须要有形参列表，同时，形参列表要与实参列表对应。

   5.5 方法体： 当我们调用一个方法时，真正执行的代码。体现了此方法的功能。

6. 注意点

   - Java 里的方法**不能独立存在**，所有的方法必须定义在类里。
   - Java 中的方法不调用，不执行。每调用一次，就执行一次。
   - 方法内可以调用本类中的(其它)方法或属性
   - 方法内不能定义方法。

7. 关键字：return

   return 的作用

   - 作用 1：结束一个方法
   - 作用 2：结束一个方法的同时，可以返回数据给方法的调用者（方法声明中如果有返回值类型，则方法内需要搭配 return 使用）

   使用注意点：return 后面不能声明执行语句。

8. 方法调用的内存解析

   - 形参：方法在声明时，一对()内声明的一个或多个形式参数，简称为形参。
   - 实参：方法在被调用时，实际传递给形参的变量或常量，就称为实际参数，简称实参。

## 再谈方法

### 方法的重载(overload)

1. 定义：在同一个类中，允许存在一个以上的同名方法，只要它们的参数列表不同即可。

   满足这样特征的多个方法，彼此之间构成方法的重载。

2. 总结为：“两同一不同”

   - 两同：同一个类、相同的方法名
   - 一不同：参数列表不同。① 参数个数不同 ② 参数类型不同

   注意：方法的重载与形参的名、权限修饰符、返回值类型都没有关系。

3. 举例

   Arrays 类中 sort(xxx[] arr)、binarySearch(xxx[] arr,xxx)、equals(xxx[] ,yyy[])

4. 如何判断两个方法是相同的呢？（换句话说，编译器是如何确定调用的某个具体的方法呢？）

   如何判断两个方法是相同的呢？ 方法名相同，且形参列表相同。（形参列表相同指的是参数个数和类型都相同，与形参名没关系）

   要求：在一个类中，允许存在多个相同名字的方法，只要他们的形参列表不同即可。

   编译器是如何确定调用的某个具体的方法呢？先通过方法名确定了一波重载的方法，进而通过不同的形参列表，确定具体的某一个方法。

5. 在同一个类中不允许定义两个相同的方法。

### 可变个数形参的方法(jdk5.0)

1. 使用场景

   在调用方法时，可能会出现方法形参的类型是确定的，但是参数的个数不确定。此时，我们就可以使用可变个数形参的方法

2. 格式：(参数类型 ... 参数名)

3. 说明：

   - 可变个数形参的方法在调用时，针对于可变的形参赋的实参的个数可以为：0 个、1 个或多个
   - 可变个数形参的方法与同一个类中，同名的多个方法之间可以构成重载
   - 特例：可变个数形参的方法与同一个类中方法名相同，且与可变个数形参的类型相同的数组参数不构成重载。
   - 可变个数的形参必须声明在形参列表的最后
   - 可变个数的形参最多在一个方法的形参列表中出现一次

### 方法的值传递机制

1. （复习）对于方法内声明的局部变量来说：如果出现赋值操作

   - 如果是基本数据类型的变量，则将此变量保存的数据值传递出去。
   - 如果是引用数据类型的变量，则将此变量保存的地址值传递出去。

2. 方法的参数的传递机制：值传递机制

   概念（复习）：

   - 形参：在定义方法时，方法名后面括号()中声明的变量称为形式参数，简称形参。
   - 实参：在调用方法时，方法名后面括号()中的使用的值/变量/表达式称为实际参数，简称实参。

   规则：实参给形参赋值的过程

   - 如果形参是基本数据类型的变量，则将实参保存的数据值赋给形参。
   - 如果形参是引用数据类型的变量，则将实参保存的地址值赋给形参。

### 递归方法

1. 何为递归方法？方法自己调用自己的现象就称为递归。

2. 递归方法分类：直接递归、间接递归

3. 使用说明：

   - 递归方法包含了一种**隐式的循环**。
   - 递归方法会**重复执行**某段代码，但这种重复执行无须循环控制。
   - 递归一定要向**已知方向**递归，否则这种递归就变成了无穷递归，停不下来，类似于**死循环**。最终发生**栈内存溢出**。

4. 注意：

   1. 递归调用会占用大量的系统堆栈，内存耗用多，在递归调用层次多时速度要比循环**慢的多**，所以在使用递归时要慎重。
   2. 在要求高性能的情况下尽量避免使用递归，递归调用既花时间又**耗内存**。考虑使用循环迭代

## Package 与 Import

### package 关键字的使用

1. 说明

   package：包。package 用于指明该文件中定义的类、接口等结构所在的包

   - 一个源文件只能有一个声明包的 package 语句
   - package 语句作为 Java 源文件的第一条语句出现。若缺省该语句，则指定为无名包。
   - 包名，属于标识符，满足标识符命名的规则和规范（全部小写）、见名知意
   - 包通常使用所在公司域名的倒置：com.atguigu.xxx。
   - 大家取包名时不要使用"`java.xx`"包
   - 包对应于文件系统的目录，package 语句中用 “.” 来指明包(目录)的层次，每.一次就表示一层文件目录。
   - 同一个包下可以声明多个结构（类、接口），但是不能定义同名的结构（类、接口）。不同的包下可以定义同名的结构（类、接口）

2. 包的作用

- 包可以包含类和子包，划分`项目层次`，便于管理
- 帮助`管理大型软件`系统：将功能相近的类划分到同一个包中。比如：MVC 的设计模式
- 解决`类命名冲突`的问题
- 控制`访问权限`

3. JDK 中主要的包

- `java.lang`----包含一些 Java 语言的核心类，如 String、Math、Integer、 System 和 Thread，提供常用功能
- `java.net`----包含执行与网络相关的操作的类和接口。
- `java.io` ----包含能提供多种输入/输出功能的类。
- `java.util`----包含一些实用工具类，如定义系统特性、接口的集合框架类、使用与日期日历相关的函数。
- `java.text`----包含了一些 java 格式化相关的类
- `java.sql`----包含了 java 进行 JDBC 数据库编程的相关类/接口
- `java.awt`----包含了构成抽象窗口工具集（abstract window toolkits）的多个类，这些类被用来构建和管理应用程序的图形用户界面(GUI)。

### import 关键字的使用

import: 导入

- import 语句来显式引入指定包下所需要的类。相当于`import语句告诉编译器到哪里去寻找这个类`。
- import 语句，声明在包的声明和类的声明之间。
- 如果需要导入多个类或接口，那么就并列显式多个 import 语句即可
- 如果使用`a.*`导入结构，表示可以导入 a 包下的所有的结构。举例：可以使用 java.util.\*的方式，一次性导入 util 包下所有的类或接口。
- 如果导入的类或接口是 java.lang 包下的，或者是当前包下的，则可以省略此 import 语句。
- 如果已经导入 java.a 包下的类，那么如果需要使用 a 包的子包下的类的话，仍然需要导入。
- 如果在代码中使用不同包下的同名的类，那么就需要使用类的全类名的方式指明调用的是哪个类。
- （了解）`import static`组合的使用：调用指定类或接口下的静态的属性或方法

## 面向对象特征之一：封装性

1. 为什么需要封装性？

   理论上：

   - `高内聚`：类的内部数据操作细节自己完成，不允许外部干涉；
   - `低耦合`：仅暴露少量的方法给外部使用，尽量方便外部调用。

   通俗的说：把该隐藏的隐藏起来，该暴露的暴露出来。这就是封装性的设计思想。

2. 如何实现数据封装？

   2.1 权限修饰符

   Java 规定了 4 种权限修饰，分别是：private、缺省、protected、public

   2.2 作用

   我们可以使用 4 种权限修饰来修饰类及类的内部成员。当这些成员被调用时，体现可见性的大小。

   2.3 实际案例：

   在题目中，我们给 Animal 的对象的 legs 属性赋值。在实际的常识中，我们知道 legs 不能赋值为负数的。但是如果
   直接调用属性 legs，是不能加入判断逻辑的。那怎么办呢？

   - 将 legs 属性私有化(private)，禁止在 Animal 类的外部直接调用此属性提供给 legs 属性赋值的 setLegs()方法，在此方法中加入 legs 赋值的判断逻辑 `if(legs >= 0 && legs % 2 ==0)`
   - 将此方法暴露出去，使得在 Animal 类的外部调用此方法，对 legs 属性赋值。
   - 提供给 legs 属性获取的 getLegs()方法，此方法对外暴露。使得在 Animal 类的外部还可以调用此属性的值。

3. 4 种权限具体使用

   《见课件》

   - 类：只能使用 public、缺省修饰
   - 类的内部成员：可以使用 4 种权限修饰进行修饰。

   开发中 4 种权限使用频率的情况：

   - 比较高：public、private
   - 比较低：缺省、protected

4. 封装性的体现

   - 场景 1：私有化(private)类的属性，提供公共(public)的 get 和 set 方法，对此属性进行获取或修改
   - 场景 2：将类中不需要对外暴露的方法，设置为 private.
   - 场景 3：单例模式中构造器 private 的了，避免在类的外部创建实例。（放到 static 关键字后讲）
