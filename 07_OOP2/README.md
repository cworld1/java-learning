# 面向对象编程（进阶）

## this 关键字的使用

1. 目前可能出现的问题？及解决方案？

   我们在声明一个属性对应的 setXxx 方法时，通过形参给对应的属性赋值。如果形参名和属性名同名了，那么该如何在方法内区分这两个变量呢？

   解决方案：使用 this。具体来讲，使用 this 修饰的变量，表示的是属性。没有用 this 修饰的，表示的是形参。

2. this 可以调用的结构：成员变量、方法、构造器

3. this 的理解：当前对象（在方法中调用时） 或 当前正在创建的对象（在构造器中调用时）

4. this 调用属性和方法

   【针对于方法内的使用情况：（准确的说是非 static 修饰的方法）】

   - 一般情况：我们通过对象 a 调用方法，可以在方法内调用当前对象 a 的属性或其他方法。此时，我们可以在属性和其他方法前使用"this."，表示当前属性或方法所属的对象 a。但是，一般情况下，我们都选择省略此"this."结构。

   - 特殊情况：如果方法的形参与对象的属性同名了，我们必须使用"this."进行区分。使用 this.修饰的变量即为属性（或成员变量），没有使用 this.修饰的变量，即为局部变量。

   【针对于构造器内的使用情况：】

   - 一般情况：我们通过构造器创建对象时，可以在构造器内调用当前正在创建的对象的属性或方法。此时，我们可以在属性和方法前使用"this."，表示当前属性或方法所属的对象。但是，一般情况下，我们都选择省略此"this."结构。

   - 特殊情况：如果构造器的形参与正在创建的对象的属性同名了，我们必须使用"this."进行区分。使用 this.修饰的变量即为属性（或成员变量），没有使用 this.修饰的变量，即为局部变量。

5. this 调用构造器

   格式："this(形参列表)"

   我们可以在类的构造器中，调用当前类中指定的其它构造器

   要求："this(形参列表)"必须声明在当前构造器的首行
   结论："this(形参列表)"在构造器中最多声明一个

   如果一个类中声明了 n 个构造器，则最多有 n-1 个构造器可以声明有"this(形参列表)"的结构

## 面向对象特征之二：继承性

1. 继承性的理解

   - 生活上：财产的继承、颜值的继承
   - 代码层面：
     - 自上而下：定义了一个类 A，在定义另一个类 B 时，发现类 B 的功能与类 A 相似，考虑类 B 继承于类 A
     - 自下而上：定义了类 B,C,D 等，发现 B、C、D 有类似的属性和方法，则可以考虑将相同的属性和方法进行抽取，封装到类 A 中，让类 B、C、D 继承于类 A,同时，B、C、D 中的相似的功能就可以删除了。

2. 继承性的好处

   - 继承的出现减少了代码冗余，提高了代码的复用性。
   - 继承的出现，更有利于功能的扩展。
   - 继承的出现让类与类之间产生了`is-a`的关系，为多态的使用提供了前提。
   - 继承描述事物之间的所属关系，这种关系是：`is-a` 的关系。可见，父类更通用、更一般，子类更具体。

3. 继承的格式：

   ```java
   class A{
      //属性、方法
   }

   class B extends A{

   }
   ```

   继承中的基本概念：

   - 类 A: 父类、superClass、超类、基类
   - 类 B: 子类、subClass、派生类

4. 有了继承性以后：

   子类就获取到了父类中声明的所有的属性和方法。但是，由于封装性的影响，可能子类不能直接调用父类中声明的属性或方法。

   子类在继承父类以后，还可以扩展自己特有的功能（体现：增加特有的属性、方法）

   extends:延展、扩展、延伸

   子类和父类的理解，要区别于集合和子集。不要为了继承而继承。在继承之前，判断一下是否有 is a 的关系。

5. 默认的父类：

   Java 中声明的类，如果没有显式的声明其父类时，则默认继承于 `java.lang.Object`

6. 补充说明：

   - Java 是支持多层继承。（概念：直接父类、间接父类）
   - Java 中的子父类的概念是相对的。
   - Java 中一个父类可以声明多个子类。反之，一个子类只能有一个父类（Java 的单继承性）
