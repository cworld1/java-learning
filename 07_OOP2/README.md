# 面向对象编程（进阶）

## this 关键字的使用

1. 目前可能出现的问题？及解决方案？

   我们在声明一个属性对应的 setXxx 方法时，通过形参给对应的属性赋值。如果形参名和属性名同名了，那么该如何在方法内区分这两个变量呢？

   解决方案：使用 this。具体来讲，使用 this 修饰的变量，表示的是属性。没有用 this 修饰的，表示的是形参。

2. this 可以调用的结构：成员变量、方法、构造器

3. this 的理解：当前对象（在方法中调用时） 或 当前正在创建的对象（在构造器中调用时）

4. this 调用属性和方法

   【针对于方法内的使用情况：（准确的说是非 static 修饰的方法）】

   - 一般情况：我们通过对象 a 调用方法，可以在方法内调用当前对象 a 的属性或其他方法。此时，我们可以在属性和其他方法前使用"this."，表示当前属性或方法所属的对象 a。但是，一般情况下，我们都选择省略此"this."结构。

   - 特殊情况：如果方法的形参与对象的属性同名了，我们必须使用"this."进行区分。使用 this.修饰的变量即为属性（或成员变量），没有使用 this.修饰的变量，即为局部变量。

   【针对于构造器内的使用情况：】

   - 一般情况：我们通过构造器创建对象时，可以在构造器内调用当前正在创建的对象的属性或方法。此时，我们可以在属性和方法前使用"this."，表示当前属性或方法所属的对象。但是，一般情况下，我们都选择省略此"this."结构。

   - 特殊情况：如果构造器的形参与正在创建的对象的属性同名了，我们必须使用"this."进行区分。使用 this.修饰的变量即为属性（或成员变量），没有使用 this.修饰的变量，即为局部变量。

5. this 调用构造器

   格式："this(形参列表)"

   我们可以在类的构造器中，调用当前类中指定的其它构造器

   要求："this(形参列表)"必须声明在当前构造器的首行
   结论："this(形参列表)"在构造器中最多声明一个

   如果一个类中声明了 n 个构造器，则最多有 n-1 个构造器可以声明有"this(形参列表)"的结构

## 面向对象特征之二：继承性

1. 继承性的理解

   - 生活上：财产的继承、颜值的继承
   - 代码层面：
     - 自上而下：定义了一个类 A，在定义另一个类 B 时，发现类 B 的功能与类 A 相似，考虑类 B 继承于类 A
     - 自下而上：定义了类 B,C,D 等，发现 B、C、D 有类似的属性和方法，则可以考虑将相同的属性和方法进行抽取，封装到类 A 中，让类 B、C、D 继承于类 A,同时，B、C、D 中的相似的功能就可以删除了。

2. 继承性的好处

   - 继承的出现减少了代码冗余，提高了代码的复用性。
   - 继承的出现，更有利于功能的扩展。
   - 继承的出现让类与类之间产生了`is-a`的关系，为多态的使用提供了前提。
   - 继承描述事物之间的所属关系，这种关系是：`is-a` 的关系。可见，父类更通用、更一般，子类更具体。

3. 继承的格式：

   ```java
   class A{
      //属性、方法
   }

   class B extends A{

   }
   ```

   继承中的基本概念：

   - 类 A: 父类、superClass、超类、基类
   - 类 B: 子类、subClass、派生类

4. 有了继承性以后：

   子类就获取到了父类中声明的所有的属性和方法。但是，由于封装性的影响，可能子类不能直接调用父类中声明的属性或方法。

   子类在继承父类以后，还可以扩展自己特有的功能（体现：增加特有的属性、方法）

   extends:延展、扩展、延伸

   子类和父类的理解，要区别于集合和子集。不要为了继承而继承。在继承之前，判断一下是否有 is a 的关系。

5. 默认的父类：

   Java 中声明的类，如果没有显式的声明其父类时，则默认继承于 `java.lang.Object`

6. 补充说明：

   - Java 是支持多层继承。（概念：直接父类、间接父类）
   - Java 中的子父类的概念是相对的。
   - Java 中一个父类可以声明多个子类。反之，一个子类只能有一个父类（Java 的单继承性）

## 重写（override）/覆盖（overwrite）

实际开发中，各权限修饰的使用频率是怎样的？ public、private 是使用频率最高的！

1. 为什么需要方法的重写？

   子类在继承父类以后，就获取了父类中声明的所有的方法。但是，父类中的方法可能不太适用于子类，换句话说，子类需要对父类中继承过来的方法进行覆盖、覆写的操作。

   举例（银行账户）：

   ```java
   class Account{//账户
      double balance;//余额

      //取钱
      public void withdraw(double amt){
         //判断balance余额是否够amt取钱的额度
      }
   }

   class CheckAccount extends Account{ //信用卡
      double protectedBy;//透支额度


      public void withdraw(double amt){
         //判断balance余额是否够amt取钱的额度
         //如果不够，还可以考虑从protectedBy额度里取
      }
   }

   class AccountTest{
      public static void main(String[] args){
         CheckAccount acct = new CheckAccount();
         acct.withdraw(); //执行的是子类重写父类的方法
      }
   }
   ```

2. 何为方法的重写？

   子类对父类继承过来的方法进行的覆盖、覆写的操作，就称为方法的重写。

3. 方法重写应遵循的规则

   [复习]方法声明的格式：`权限修饰符 返回值类型 方法名(形参列表) [throws 异常类型] { //方法体 }`

   具体规则：

   1. 父类被重写的方法与子类重写的方法的方法名和形参列表必须相同。
   2. 子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符

      子类不能重写父类中声明为 private 权限修饰的方法。

   3. 关于返回值类型：

      - 父类被重写的方法的返回值类型是 void，则子类重写的方法的返回值类型必须是 void

      - 父类被重写的方法的返回值类型是基本数据类型，则子类重写的方法的返回值类型必须与被重写的方法的返回值类型相同。

      - 父类被重写的方法的返回值类型是引用数据类型(比如类)，则子类重写的方法的返回值类型可以与被重写的方法的返回值类型相同 或 是被重写的方法的返回值类型的子类

   4. （超纲）子类重写的方法抛出的异常类型可以与父类被重写的方法抛出的异常类型相同，或是父类被重写的方法抛出的异常类型的子类。

   补充说明：方法体：没有要求。但是子类重写的方法的方法体必然与父类被重写的方法的不同。

4. 面试题：区分方法的重载(overload)与重写(override / overwrite)

   重载：“两同一不同”
   重写：继承以后，子类覆盖父类中同名同参数的方法

   [类比]相同类型的面试题：

   - throws / throw
   - final / finally / finalize
   - Collection / Collections
   - String / StringBuffer / StringBuilder
   - ArrayList / LinkedList
   - HashMap / LinkedHashMap / Hashtable
   - ...
   - sleep() / wait()
   - == / equals()
   - 同步 / 异步

## super 关键字的使用

1. 为什么需要 super？

   举例 1：子类继承父类以后，对父类的方法进行了重写，那么在子类中，是否还可以对父类中被重写的方法进行调用？
   可以！

   举例 2：子类继承父类以后，发现子类和父类中定义了同名的属性，是否可以在子类中区分两个同名的属性？
   可以！

   如何调用？ 使用 super 关键字即可。

2. super 的理解：父类的

3. super 可以调用的结构：属性、方法、构造器

   具体的：

   3.1 super 调用属性、方法

   子类继承父类以后，我们就可以在子类的方法或构造器中，调用父类中声明的属性或方法。（满足封装性的前提下）

   如何调用呢？需要使用"super."的结构，表示调用父类的属性或方法。

   一般情况下，我们可以考虑省略"super."的结构。但是，如果出现子类重写了父类的方法或子父类中出现了同名的属性时，则必须使用"super."的声明，显式的调用父类被重写的方法或父类中声明的同名的属性。

   3.2 super 调用构造器

   - ① 子类继承父类时，不会继承父类的构造器。只能通过“super(形参列表)”的方式调用父类指定的构造器。
   - ② 规定：“super(形参列表)”，必须声明在构造器的首行。
   - ③ 我们前面讲过，在构造器的首行可以使用"this(形参列表)"，调用本类中重载的构造器，结合 ②，结论：在构造器的首行，"this(形参列表)" 和 "super(形参列表)"只能二选一。
   - ④ 如果在子类构造器的首行既没有显示调用"this(形参列表)"，也没有显式调用"super(形参列表)"，则子类此构造器默认调用"super()"，即调用父类中空参的构造器。
   - ⑤ 由 ③ 和 ④ 得到结论：子类的任何一个构造器中，要么会调用本类中重载的构造器，要么会调用父类的构造器。只能是这两种情况之一。
   - ⑥ 由 ⑤ 得到：一个类中声明有 n 个构造器，最多有 n-1 个构造器中使用了"this(形参列表)"，则剩下的那个一定使用"super(形参列表)"。

   --> 我们在通过子类的构造器创建对象时，一定在调用子类构造器的过程中，直接或间接的调用到父类的构造器。
   也正因为调用过父类的构造器，我们才会将父类中声明的属性或方法加载到内存中，供子类对象使用。

## 子类对象实例化全过程

代码举例：

```java
class Creature{ //生物类
    //声明属性、方法、构造器
}

class Animal extends Creature{ //动物类

}

class Dog extends Animal{ //狗类

}

class DogTest{
    public static void main(String[] args){
        Dog dog = new Dog();
        dog.xxx();
        dog.yyy = ...;
    }
}
```

1. 从结果的角度来看：体现为类的继承性

   当我们创建子类对象后，子类对象就获取了其父类中声明的所有的属性和方法，在权限允许的情况下，可以直接调用。

2. 从过程的角度来看：

   当我们通过子类的构造器创建对象时，子类的构造器一定会直接或间接的调用到其父类的构造器，而其父类的构造器同样会直接或间接的调用到其父类的父类的构造器，....，直到调用了 Object 类中的构造器为止。

   正因为我们调用过子类所有的父类的构造器，所以我们就会将父类中声明的属性、方法加载到内存中，供子类的对象使用。

   问题：在创建子类对象的过程中，一定会调用父类中的构造器吗？ yes!

3. 问题：创建子类的对象时，内存中到底有几个对象？

   就只有一个对象！即为当前 new 后面构造器对应的类的对象。

