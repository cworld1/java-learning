# 面向对象编程（进阶）

## this 关键字的使用

1. 目前可能出现的问题？及解决方案？

   我们在声明一个属性对应的 setXxx 方法时，通过形参给对应的属性赋值。如果形参名和属性名同名了，那么该如何在方法内区分这两个变量呢？

   解决方案：使用 this。具体来讲，使用 this 修饰的变量，表示的是属性。没有用 this 修饰的，表示的是形参。

2. this 可以调用的结构：成员变量、方法、构造器

3. this 的理解：当前对象（在方法中调用时） 或 当前正在创建的对象（在构造器中调用时）

4. this 调用属性和方法

   【针对于方法内的使用情况：（准确的说是非 static 修饰的方法）】

   - 一般情况：我们通过对象 a 调用方法，可以在方法内调用当前对象 a 的属性或其他方法。此时，我们可以在属性和其他方法前使用"this."，表示当前属性或方法所属的对象 a。但是，一般情况下，我们都选择省略此"this."结构。

   - 特殊情况：如果方法的形参与对象的属性同名了，我们必须使用"this."进行区分。使用 this.修饰的变量即为属性（或成员变量），没有使用 this.修饰的变量，即为局部变量。

   【针对于构造器内的使用情况：】

   - 一般情况：我们通过构造器创建对象时，可以在构造器内调用当前正在创建的对象的属性或方法。此时，我们可以在属性和方法前使用"this."，表示当前属性或方法所属的对象。但是，一般情况下，我们都选择省略此"this."结构。

   - 特殊情况：如果构造器的形参与正在创建的对象的属性同名了，我们必须使用"this."进行区分。使用 this.修饰的变量即为属性（或成员变量），没有使用 this.修饰的变量，即为局部变量。

5. this 调用构造器

   格式："this(形参列表)"

   我们可以在类的构造器中，调用当前类中指定的其它构造器

   要求："this(形参列表)"必须声明在当前构造器的首行
   结论："this(形参列表)"在构造器中最多声明一个

   如果一个类中声明了 n 个构造器，则最多有 n-1 个构造器可以声明有"this(形参列表)"的结构

## 面向对象特征之二：继承性

1. 继承性的理解

   - 生活上：财产的继承、颜值的继承
   - 代码层面：
     - 自上而下：定义了一个类 A，在定义另一个类 B 时，发现类 B 的功能与类 A 相似，考虑类 B 继承于类 A
     - 自下而上：定义了类 B,C,D 等，发现 B、C、D 有类似的属性和方法，则可以考虑将相同的属性和方法进行抽取，封装到类 A 中，让类 B、C、D 继承于类 A,同时，B、C、D 中的相似的功能就可以删除了。

2. 继承性的好处

   - 继承的出现减少了代码冗余，提高了代码的复用性。
   - 继承的出现，更有利于功能的扩展。
   - 继承的出现让类与类之间产生了`is-a`的关系，为多态的使用提供了前提。
   - 继承描述事物之间的所属关系，这种关系是：`is-a` 的关系。可见，父类更通用、更一般，子类更具体。

3. 继承的格式：

   ```java
   class A{
      //属性、方法
   }

   class B extends A{

   }
   ```

   继承中的基本概念：

   - 类 A: 父类、superClass、超类、基类
   - 类 B: 子类、subClass、派生类

4. 有了继承性以后：

   子类就获取到了父类中声明的所有的属性和方法。但是，由于封装性的影响，可能子类不能直接调用父类中声明的属性或方法。

   子类在继承父类以后，还可以扩展自己特有的功能（体现：增加特有的属性、方法）

   extends:延展、扩展、延伸

   子类和父类的理解，要区别于集合和子集。不要为了继承而继承。在继承之前，判断一下是否有 is a 的关系。

5. 默认的父类：

   Java 中声明的类，如果没有显式的声明其父类时，则默认继承于 `java.lang.Object`

6. 补充说明：

   - Java 是支持多层继承。（概念：直接父类、间接父类）
   - Java 中的子父类的概念是相对的。
   - Java 中一个父类可以声明多个子类。反之，一个子类只能有一个父类（Java 的单继承性）

## 重写（override）/覆盖（overwrite）

实际开发中，各权限修饰的使用频率是怎样的？ public、private 是使用频率最高的！

1. 为什么需要方法的重写？

   子类在继承父类以后，就获取了父类中声明的所有的方法。但是，父类中的方法可能不太适用于子类，换句话说，子类需要对父类中继承过来的方法进行覆盖、覆写的操作。

   举例（银行账户）：

   ```java
   class Account{//账户
      double balance;//余额

      //取钱
      public void withdraw(double amt){
         //判断balance余额是否够amt取钱的额度
      }
   }

   class CheckAccount extends Account{ //信用卡
      double protectedBy;//透支额度


      public void withdraw(double amt){
         //判断balance余额是否够amt取钱的额度
         //如果不够，还可以考虑从protectedBy额度里取
      }
   }

   class AccountTest{
      public static void main(String[] args){
         CheckAccount acct = new CheckAccount();
         acct.withdraw(); //执行的是子类重写父类的方法
      }
   }
   ```

2. 何为方法的重写？

   子类对父类继承过来的方法进行的覆盖、覆写的操作，就称为方法的重写。

3. 方法重写应遵循的规则

   [复习]方法声明的格式：`权限修饰符 返回值类型 方法名(形参列表) [throws 异常类型] { //方法体 }`

   具体规则：

   1. 父类被重写的方法与子类重写的方法的方法名和形参列表必须相同。
   2. 子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符

      子类不能重写父类中声明为 private 权限修饰的方法。

   3. 关于返回值类型：

      - 父类被重写的方法的返回值类型是 void，则子类重写的方法的返回值类型必须是 void

      - 父类被重写的方法的返回值类型是基本数据类型，则子类重写的方法的返回值类型必须与被重写的方法的返回值类型相同。

      - 父类被重写的方法的返回值类型是引用数据类型(比如类)，则子类重写的方法的返回值类型可以与被重写的方法的返回值类型相同 或 是被重写的方法的返回值类型的子类

   4. （超纲）子类重写的方法抛出的异常类型可以与父类被重写的方法抛出的异常类型相同，或是父类被重写的方法抛出的异常类型的子类。

   补充说明：方法体：没有要求。但是子类重写的方法的方法体必然与父类被重写的方法的不同。

4. 面试题：区分方法的重载(overload)与重写(override / overwrite)

   重载：“两同一不同”
   重写：继承以后，子类覆盖父类中同名同参数的方法

   [类比]相同类型的面试题：

   - throws / throw
   - final / finally / finalize
   - Collection / Collections
   - String / StringBuffer / StringBuilder
   - ArrayList / LinkedList
   - HashMap / LinkedHashMap / Hashtable
   - ...
   - sleep() / wait()
   - == / equals()
   - 同步 / 异步

## super 关键字的使用

1. 为什么需要 super？

   举例 1：子类继承父类以后，对父类的方法进行了重写，那么在子类中，是否还可以对父类中被重写的方法进行调用？
   可以！

   举例 2：子类继承父类以后，发现子类和父类中定义了同名的属性，是否可以在子类中区分两个同名的属性？
   可以！

   如何调用？ 使用 super 关键字即可。

2. super 的理解：父类的

3. super 可以调用的结构：属性、方法、构造器

   具体的：

   3.1 super 调用属性、方法

   子类继承父类以后，我们就可以在子类的方法或构造器中，调用父类中声明的属性或方法。（满足封装性的前提下）

   如何调用呢？需要使用"super."的结构，表示调用父类的属性或方法。

   一般情况下，我们可以考虑省略"super."的结构。但是，如果出现子类重写了父类的方法或子父类中出现了同名的属性时，则必须使用"super."的声明，显式的调用父类被重写的方法或父类中声明的同名的属性。

   3.2 super 调用构造器

   - ① 子类继承父类时，不会继承父类的构造器。只能通过“super(形参列表)”的方式调用父类指定的构造器。
   - ② 规定：“super(形参列表)”，必须声明在构造器的首行。
   - ③ 我们前面讲过，在构造器的首行可以使用"this(形参列表)"，调用本类中重载的构造器，结合 ②，结论：在构造器的首行，"this(形参列表)" 和 "super(形参列表)"只能二选一。
   - ④ 如果在子类构造器的首行既没有显示调用"this(形参列表)"，也没有显式调用"super(形参列表)"，则子类此构造器默认调用"super()"，即调用父类中空参的构造器。
   - ⑤ 由 ③ 和 ④ 得到结论：子类的任何一个构造器中，要么会调用本类中重载的构造器，要么会调用父类的构造器。只能是这两种情况之一。
   - ⑥ 由 ⑤ 得到：一个类中声明有 n 个构造器，最多有 n-1 个构造器中使用了"this(形参列表)"，则剩下的那个一定使用"super(形参列表)"。

   --> 我们在通过子类的构造器创建对象时，一定在调用子类构造器的过程中，直接或间接的调用到父类的构造器。
   也正因为调用过父类的构造器，我们才会将父类中声明的属性或方法加载到内存中，供子类对象使用。

## 子类对象实例化全过程

代码举例：

```java
class Creature{ //生物类
    //声明属性、方法、构造器
}

class Animal extends Creature{ //动物类

}

class Dog extends Animal{ //狗类

}

class DogTest{
    public static void main(String[] args){
        Dog dog = new Dog();
        dog.xxx();
        dog.yyy = ...;
    }
}
```

1. 从结果的角度来看：体现为类的继承性

   当我们创建子类对象后，子类对象就获取了其父类中声明的所有的属性和方法，在权限允许的情况下，可以直接调用。

2. 从过程的角度来看：

   当我们通过子类的构造器创建对象时，子类的构造器一定会直接或间接的调用到其父类的构造器，而其父类的构造器同样会直接或间接的调用到其父类的父类的构造器，....，直到调用了 Object 类中的构造器为止。

   正因为我们调用过子类所有的父类的构造器，所以我们就会将父类中声明的属性、方法加载到内存中，供子类的对象使用。

   问题：在创建子类对象的过程中，一定会调用父类中的构造器吗？ yes!

3. 问题：创建子类的对象时，内存中到底有几个对象？

   就只有一个对象！即为当前 new 后面构造器对应的类的对象。

## 面向对象特征之三：多态性

1. 如何理解多态性？

   理解：理解为一个事物的多种形态。

   生活举例：

   - 女朋友：我想养一个宠物。
   - 孩子：我想要一个玩具。
   - 老板：张秘书，安排一个技术科的同事，跟我一起下周出差。

2. Java 中多态性的体现:

   子类对象的多态性：父类的引用指向子类的对象。（或子类的对象赋给父类的引用）

   比如：`Person p2 = new Man();`

3. 多态性的应用：

   多态性的应用：虚拟方法调用

   在多态的场景下，调用方法时。

   - 编译时，认为方法是左边声明的父类的类型的方法（即被重写的方法）
   - 执行时，实际执行的是子类重写父类的方法。

   简称为：编译看左边，运行看右边。

4. 多态性的使用前提：① 要有类的继承关系 ② 要有方法的重写

5. 多态的适用性：适用于方法，不适用于属性。

6. 多态的好处与弊端

   6.1 弊端：

   在多态的场景下，我们创建了子类的对象，也加载了子类特有的属性和方法。但是由于声明为父类的引用，导致我们没有办法直接调用子类特有的属性和方法。

   6.2 好处：

   极大的减少了代码的冗余，不需要定义多个重载的方法。

   举例：

   ```java
   class Account{
      public void withdraw(){} //取钱
   }

   class CheckAccount extends Account{ //信用卡
      //存在方法的重写
      public void withdraw(){} //取钱
   }
   class SavingAccount extends Account{ //储蓄卡
      //存在方法的重写
   }

   class Customer{
      Account account;

      public void setAccount(Account account){
         this.account = account;
      }

      public Account getAccount(){
         return accout;
      }

   }

   class CustomerTest{
      main(){
         Customer cust = new Customer();
         cust.setAccount(new CheckAccount());

         cust.getAccount().withdraw();

      }
   }
   ```

7. instanceof 的使用

   1. 建议在向下转型之前，使用 instanceof 进行判断，避免出现类型转换异常
   2. 格式： a instanceOf A : 判断对象 a 是否是类 A 的实例。
   3. 如果 a instanceOf A 返回 true，则：a instanceOf superA 返回也是 true。其中，A 是 superA 的子类。

## Object 类的概述

1. Object 类的说明

   - 明确：java.lang.Object
   - 任何一个 Java 类（除 Object 类）都直接或间接的继承于 Object 类
   - Object 类称为 java 类的根父类
   - Object 类中声明的结构（属性、方法等）就具有通用性。

     - Object 类中没有声明属性
     - Object 类提供了一个空参的构造器
     - 重点关注：Object 类中声明的方法

2. 常用方法

   - 重点方法：equals() \ toString()
   - 了解方法：clone() \ finalize()
   - 目前不需要关注：getClass() \ hashCode() \ notify() \ notifyAll() \ wait() \ wait(xx) \ wait(xx,yy)

   面试题：final 、 finally 、 finalize 的区别

3. equals()的使用

   3.1 适用性：

   任何引用数据类型都可以使用。

   3.2 `java.lang.Object` 类中 `equals()` 的定义：

   ```java
   public boolean equals(Object obj) {
      return (this == obj);
   }
   ```

   3.3 子类使用说明：

   自定义的类在没有重写 Object 中 equals()方法的情况下，调用的就是 Object 类中声明的 equals()，比较两个对象的引用地址是否相同。（或比较两个对象是否指向了堆空间中的同一个对象实体）

   对于像 String、File、Date 和包装类等，它们都重写了 Object 类中的 equals()方法，用于比较两个对象的实体内容是否相等。

   3.4 开发中使用说明：

   实际开发中，针对于自定义的类，常常会判断两个对象是否 equals()，而此时主要是判断两个对象的属性值是否相等。

   所以：我们要重写 Object 类的 equals()方法。

   如何重写:

   - 手动自己实现
   - 调用 IDEA 自动实现（推荐）

   高频面试题： 区分 == 和 equals()

   ==：运算符
   ① 使用范围：基本数据类型、引用数据类型
   ② 基本数据类型：判断数据值是否相等

   ```java
   int i1 = 10;
   int i2 = 10;
   sout(i1 == i2);//true

   char c1 = 'A';
   int i3 = 65;
   sout(c1 == i3);//true

   float f1 = 12.0F;
   int i4 = 12;
   sout(f1 == i4);//true
   ```

   引用数据类型变量：比较两个引用变量的地址值是否相等。（或比较两个引用是否指向同一个对象实体）

   equals()：方法

   - 使用范围：只能使用在引用数据类型上。
   - 具体使用：对于类来说，重写 equals()和不重写 equals()的区别。

4. toString()的使用

   4.1 Object 类中 toString()的定义：

   ```java
   public String toString() {
      return getClass().getName() + "@" + Integer.toHexString(hashCode());
   }
   ```

   4.2 开发中的使用场景

   平时我们在调用 `System.out.println()` 打印对象引用变量时，其实就调用了对象的 `toString()`

   4.3 子类使用说明：

   自定义的类，在没有重写 Object 类的 toString()的情况下，默认返回的是当前对象的地址值。

   像 String、File、Date 或包装类等 Object 的子类，它们都重写了 Object 类的 toString()，在调用 toString()时，返回当前对象的实体内容。

   4.4 开发中使用说明：

   习惯上，开发中对于自定义的类在调用 toString()时，也希望显示其对象的实体内容，而非地址值。这时候，就需要重写 Object 类中的 toString().
